"Executing " dot *source* dot nl

\ Pull in libs.

"builtins" require
"time" require
"math" require
"sys" require
"os" require
"os.path" require
"io" require

\ Basic aliases

'dot          '.          alias
'colon        ':          alias
'semi         ';          alias
'bounded_list '[list]     alias
'list         '->list     alias
'to_arglist   '->arglist  alias
'list_to_map  'list->map  alias
'lookup       '@@         alias
'call         '!!         alias
'add          '+          alias
'sub          '-          alias
'mul          '*          alias
'div          '/          alias
'gt           '>          alias
'lt           '<          alias
'le           '<=         alias
'ge           '>=         alias
'eq           '=          alias
'current_ns   '*ns*       alias

: *prompt* "Sally> " ;

'list-marker unique def
: [ list-marker ;
: ] list-marker [list] ;

: [] ( -- <empty list>) [ ] ;

'map-marker unique def
: { map-marker ;
: } map-marker [list] list->map ;

: {} ( -- <empty map>) { } ;

'set-marker unique def
: {{ set-marker ;
: }} 
    set-marker [list]                 \ Turn elements into list
    set-marker swap set-marker [list] \ Nest list in argument list
    builtins.set !!                   \ Call set with 1 argument 
;

: {{}} ( -- <empty set>) {{ }} ;

: [: [ ;
: :] ] ->arglist ;

: => [ ;
: >! ] arrow ;

: <. [ ;
: .> ] arrow ;

: !!0 [] swap call ;

: type 1 ->list builtins.type !! ;

: ctime [] time.ctime ;
: sleep 1 ->list stack time.sleep drop ;

: callable? 1 ->list builtins.callable ;

: hello "Hello" . nl ;

: >0 0 > ;
: <0 0 < ;
: >1 1 > ;
: <1 1 < ;

: p . nl ;
: top dup p ;

: --  -1 + ;
: ++  1 + ;
: pos?  0 > ;
: neg?  0 < ;
: zero? 0 = ;

: source-if-exists 
    (path --)
    dup 
    1 ->list os.path.exists
    if source else drop then
;

: << [ ;
: >>@ ] @@ ;
: >>! ] @@ [] swap !! ;

"init.sf" source-if-exists


