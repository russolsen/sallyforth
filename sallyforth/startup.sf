\ "Executing " dot *source* dot nl

\ Pull in libs.

"builtins" require
"time" require
"math" require
"sys" require
"os" require
"os.path" require
"io" require
"time" require

\ Basic aliases

'None         'nil        alias
'dot          '.          alias
'colon        ':          alias
'semi         ';          alias
'thread       '@@         alias
'exit_bang    'exit!      alias
'bounded_list '[list]     alias
'list         '->list     alias
'to_arglist   '->arglist  alias
'list_to_map  'list->map  alias
'call         '!!         alias
'add          '+          alias
'sub          '-          alias
'mul          '*          alias
'div          '/          alias
'gt           '>          alias
'lt           '<          alias
'le           '<=         alias
'ge           '>=         alias
'eq           '=          alias
'current_ns   '*ns*       alias

: *prompt* "Sally> " ;

\ Make a list.
'list-marker unique def
: [ list-marker ;
: ] list-marker [list] ;

: [] ( -- <empty list>) [ ] ;


\ Look up attributes on a value.
: <. [ ;
: .> ] thread ;
: $? swap ;

\ Call native functions with various # arguments.
: !!0 [] swap !! ;
: !!1 swap 1 ->list swap !! ;  
: !!2 swap 2 ->list swap !! ;  

\ Make a map.
'map-marker unique def
: { map-marker ;
: } map-marker [list] list->map ;

: {} ( -- <empty map>) { } ;


\ Make a set.

'set-marker unique def
: {{ set-marker ;
: }} 
    set-marker [list]                 \ Turn elements into list
    set-marker swap set-marker [list] \ Nest list in argument list
    builtins.set !!                   \ Call set with 1 argument 
;

: {{}} ( -- <empty set>) {{ }} ;

: [: [ ;
: :] ] ->arglist ;


: type builtins.type !!1 ;

: ctime time.ctime !!0 ;

: sleep time.sleep !!1 drop ;

: callable? builtins.callable !!1 ;

: hello "Hello" . nl ;

: >0 0 > ;
: =0 0 = ;
: <1 1 < ;
: <0 0 < ;
: >1 1 > ;
: <1 1 < ;

: p . nl ;
: top dup p ;

: --    -1 + ;
: ++    1 + ;
: *2    2 * ;
: pos?  0 > ;
: neg?  0 < ;
: zero? 0 = ;

: exists? os.path.exists !!1 ;

: source-if-exists 
  (path -- result-of-sourcing)
  dup 
  exists?
  if source else drop then
;

: getattr ( obj attr -- attr-value ) swap 2 ->list builtins.getattr !! ;

: .!! (obj args method-name -- result) tbm getattr !! ;
: .!!0 (obj method-name -- result ) [] swap .!! ;
: .!!1 (obj arg method-name -- result ) swap 1 ->list swap .!! ;
: .!!2 (obj a1 a2 method-name -- result ) swap 2 ->list swap .!! ;
: .!!3 (obj a1 a2 a3 method-name -- result ) swap 3 ->list swap .!! ;

\ todo : tokenize #forth.tokenizer.tokenize  !!1 ;

"string.sf" source
"list.sf" source
"io.sf" source

"init.sf" source-if-exists
