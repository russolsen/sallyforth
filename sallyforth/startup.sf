\ "Executing " dot *source* dot nl

\ Pull in libs.

"builtins" require
"time" require
"math" require
"sys" require
"os" require
"os.path" require
"io" require
"time" require

'builtins import

\ Basic aliases

'None         'nil        alias
'dot          '.          alias
'colon        ':          alias
'semi         ';          alias
'thread       '@@         alias
'exit_bang    'exit!      alias
'bounded_list '[list]     alias
'list         '->list     alias
'to_arglist   '->arglist  alias
'list_to_map  'list->map  alias
'call         '!!         alias
'add          '+          alias
'sub          '-          alias
'mul          '*          alias
'div          '/          alias
'gt           '>          alias
'lt           '<          alias
'le           '<=         alias
'ge           '>=         alias
'eq           '=          alias
'current_ns   '*ns*       alias

: *prompt* "Sally> " ;
: *execute-command* stack execute ;

\ Make a list.
'list-marker unique def
: [ list-marker inline ;
: ] list-marker [list] inline ;

: [] ( -- <empty list>) [ ] inline ;


\ Look up attributes on a value.
: <. [ ;
: .> ] thread ;
: $? swap ;

\ Call native functions with various # arguments.
: !!0 [] swap !! inline ;
: !!1 swap 1 ->list swap !! inline ;  
: !!2 swap 2 ->list swap !! inline ;  

\ Make a map.
'map-marker unique def
: { map-marker inline ;
: } map-marker [list] list->map inline ;

: {} ( -- <empty map>) { } inline ;


\ Make a set.

'set-marker unique def
: {{ set-marker ;
: }} 
    set-marker [list]                 \ Turn elements into list
    set-marker swap set-marker [list] \ Nest list in argument list
    builtins.set !!                   \ Call set with 1 argument 
    inline
;

: {{}} ( -- <empty set>) {{ }} inline ;

: [: [ inline ;
: :] ] ->arglist inline ;


: str builtins.str !!1 ;

: type builtins.type !!1 ;

: type? (x class -- bool) swap type = ;

: ctime time.ctime !!0 ;

: sleep time.sleep !!1 drop ;

: callable? builtins.callable !!1 ;

: hello "Hello" . nl ;

: >0 0 > inline ;
: =0 0 = inline ;
: <1 1 < inline ;
: <0 0 < inline ;
: >1 1 > inline ;
: <1 1 < inline ;

: p . nl ;
: top dup p ;

: --    -1 + inline ;
: ++    1 + inline ;
: *2    2 * inline ;
: pos?  0 > inline ;
: neg?  0 < inline ;
: zero? 0 = inline ;

: exists? os.path.exists !!1 ;

: source-if-exists 
  (path -- result-of-sourcing)
  dup 
  exists?
  if source else drop then
;

: getattr ( obj attr -- attr-value ) swap 2 ->list builtins.getattr !! ;

: .!! (obj args method-name -- result) tbm getattr !! ;
: .!!0 (obj method-name -- result ) [] swap .!! ;
: .!!1 (obj arg method-name -- result ) swap 1 ->list swap .!! ;
: .!!2 (obj a1 a2 method-name -- result ) swap 2 ->list swap .!! ;
: .!!3 (obj a1 a2 a3 method-name -- result ) swap 3 ->list swap .!! ;

: assert ( bool msg -- )
  swap
  if 
    "OK " . p
  else
    #builtins.AssertionError !!1
    raise
  then
;
    

"string.sf" source
"list.sf" source
"io.sf" source

"init.sf" source-if-exists
