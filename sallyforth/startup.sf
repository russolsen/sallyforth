"Executing " dot *source* dot nl

\ Pull in libs.

"builtins" require
"time" require
"math" require
"sys" require
"os" require
"os.path" require
"io" require

\ Basic aliases

'dot          '.          alias
'colon        ':          alias
'semi         ';          alias
'bounded_list '[list]     alias
'list         '->list     alias
'list_to_map  'list->map  alias
'lookup       '@@         alias
'call         '!!         alias
'add          '+          alias
'sub          '-          alias
'mul          '*          alias
'div          '/          alias
'gt           '>          alias
'lt           '<          alias
'le           '<=         alias
'ge           '>=         alias
'eq           '=          alias

: *prompt* "Sally> " ;

'list-marker unique def
: [ list-marker ;
: ] list-marker [list] ;

: [] ( -- <empty list>) [ ] ;

'map-marker unique def
: { map-marker ;
: } map-marker [list] list->map ;

: {} ( -- <empty map>) { } ;

'set-marker unique def
: {{ set-marker ;
: }} 
    set-marker [list]                 \ Turn elements into list
    set-marker swap set-marker [list] \ Nest list in argument list
    builtins.set !!                   \ Call set with 1 argument 
;

: {{}} ( -- <empty set>) {{ }} ;

: type (x -- type-of-x) 1 ->list builtins.type !! ;

: px0 (mod fname -- result) []  px ;
: px1 (mod fname arg -- result) 1 ->list px ;
: px2 (mod fname arg arg -- result) 2 ->list px ;
: px3 (mod fname arg arg arg -- result) 3 ->list px ;

: dir (mod -- keys) "dir" px0 ;
: ctime [] time.ctime ;
: sleep 1 ->list stack time.sleep drop ;

: hello (simple greeting) "Hello" . nl ;

: >0 0 > ;
: <0 0 < ;
: >1 1 > ;
: <1 1 < ;

: p . nl ;
: top dup p ;

: -- ( n -- n-1 ) -1 + ;
: ++ ( n -- n+1 ) 1 + ;
: pos? (n -- bool) 0 > ;
: neg? (n -- bool) 0 < ;
: zero? (n -- bool) 0 = ;

: source-if-exists (path --)
    dup 
    1 ->list os.path.exists
    if source else drop then
;

: << [ ;
: >> ] @@ ;

"init.sf" source-if-exists


